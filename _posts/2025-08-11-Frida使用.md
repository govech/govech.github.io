---
title: Frida使用
date: 2025-08-11
---



使用 Frida 进行 Android App Hook 是一个非常自然的选择。以下是详细步骤指南，结合了你的技术栈优势：

------

### **一、 核心流程概述**

1. **环境准备** (Python 环境)
2. **目标设备/模拟器设置**
3. **编写 Frida Hook 脚本** (JavaScript)
4. **使用 Python 控制 Frida 执行 Hook**
5. **分析结果**

------

### **二、 详细步骤**

#### **1. 环境准备 (Python 侧)**

```
# 安装 Frida Python 工具包 (核心)
pip install frida frida-tools

# 验证安装 (查看 Frida 版本)
frida --version
```

#### **2. 目标设备/模拟器设置**

- **方案 A: 物理设备 (需 ROOT)**

  - 从 https://github.com/frida/frida/releases下载对应设备架构 (通常是 `android-arm64`) 的 `frida-server-xx.x.x-android-xx.x.x.xz`

  - 解压得到 `frida-server`

  - 推送至设备并赋予执行权限：

    ```
    adb root # 可能需要 ROOT 设备
    adb push frida-server /data/local/tmp/
    adb shell "chmod 755 /data/local/tmp/frida-server"
    ```

  - 运行服务：

    ```
    adb shell "/data/local/tmp/frida-server &"
    ```

- **方案 B: 模拟器 (推荐)**

  - 使用 **Android Studio 的官方模拟器** (如 `Pixel 5 API 33`)。
  - 下载对应架构的 `frida-server`(模拟器通常是 `x86_64`)。
  - 推送并运行步骤同上 (无需真实 ROOT)。

- **验证连接:**

  ```
  frida-ps -U # 列出 USB 连接的设备进程
  # 应能看到设备上的进程列表 (如 android.process.acore, com.android.settings)
  ```

------

### **三、 编写 Frida Hook 脚本 (JavaScript)**

**文件名：** `hook_script.js`

#### **核心 Hook 模式 (你的 Java/Kotlin 知识用在这里！)**

```
Java.perform(function () { // 关键：确保在 Java 线程上下文执行

  // ⭐⭐ 场景 1: Hook 普通 Java 方法 ⭐⭐
  // 定位目标类 (完整包名+类名)
  const TargetClass = Java.use('com.example.app.TargetClass');

  // Hook 指定方法 (注意方法签名！你的 Java 知识!)
  TargetClass.targetMethod.implementation = function (param1, param2) {
    // (1) 打印参数
    console.log('[+] Hooked targetMethod!');
    console.log('  |- Param1:', param1);
    console.log('  |- Param2:', param2.toString()); // 复杂对象可调用 toString()

    // (2) 修改参数 (可选)
    let newParam = "Hacked!";
    // let newParam = param2 + "_modified";

    // (3) 调用原方法 (可选) - 使用 'this' 指代原对象实例
    let result = this.targetMethod(param1, newParam); 

    // (4) 修改返回值 (可选)
    // result = "Fake Result";

    // (5) 打印返回值
    console.log('  `- Return:', result);

    // (6) 返回结果
    return result;
  };

  // ⭐⭐ 场景 2: Hook 重载方法 ⭐⭐
  // 通过参数列表区分重载
  TargetClass.overloadedMethod.overload('int', 'java.lang.String').implementation = function (i, str) {
    console.log(`Hooked overloadedMethod(int, String): ${i}, ${str}`);
    return this.overloadedMethod(i, "Modified_" + str); // 调用原方法并修改参数
  };

  // ⭐⭐ 场景 3: Hook 构造方法 ⭐⭐
  TargetClass.$init.overload('android.content.Context', 'int').implementation = function (ctx, type) {
    console.log(`New TargetClass created! Type: ${type}`);
    // 执行原构造方法 ($init 代表构造函数)
    this.$init(ctx, 999); // 偷偷修改构造参数！
  };

  // ⭐⭐ 场景 4: Hook 匿名内部类 (你的 Android 知识!) ⭐⭐
  // 关键：定位内部类名 (通常在外部类名后加 $ 和数字/名称)
  const OnClickListener = Java.use('com.example.app.MainActivity$1');
  OnClickListener.onClick.implementation = function (v) {
    console.log('Button clicked via Hook!');
    this.onClick(v); // 继续执行原点击逻辑
    // return; // 阻止点击事件
  };

});
```

------

### **四、 使用 Python 控制 Frida 执行 (你的 Python 优势在此！)**

**文件名：** `frida_controller.py`

```python
import frida
import sys

def on_message(message, data):
    if message['type'] == 'send':  # 接收来自 JS 的 console.log
        print(f"[APP] {message['payload']}")
    else:  # 错误信息
        print(f"[ERROR] {message}")

# 1. 连接到 USB 设备
device = frida.get_usb_device()

# 2. 选择目标 APP
# 方式 A: Attach 到已运行的进程 (需进程名)
# pid = device.spawn(["com.example.targetapp"])  # 如果需要启动
# process = device.attach(pid)

# 方式 B: 附加到已运行进程
process = device.attach("com.example.targetapp") 

# 3. 加载 JS Hook 脚本
with open("hook_script.js", "r", encoding="utf-8") as f:
    jscode = f.read()
script = process.create_script(jscode)
script.on('message', on_message)  # 绑定消息处理函数

# 4. 执行 Hook!
print("Starting Hook...")
script.load()

# 5. 保持脚本运行 (Python 不退出)
print("Hooking running. Press Ctrl+C to stop.")
sys.stdin.read()  # 阻塞等待用户输入终止
```

------

### **五、 运行流程**

1. 确保 `frida-server`已在设备/模拟器运行。

2. 启动目标 App (或被 Hook 的 App)。

3. 执行 Python 控制脚本：

   ```
   python frida_controller.py
   ```

4. 在 App 中操作被 Hook 的功能，观察控制台输出。

------

### **六、 关键技巧 (利用你的开发背景)**

1. **快速定位类名/方法名：**

   - 使用 `Jadx`/`Ghidra`反编译目标 APK。

   - 在 Android Studio 中调试自己的 App (你知道关键断点位置)。

   - 使用 `frida-trace`快速追踪类/方法：

     ```
     frida-trace -U -p <PID> -j "com.example.app.*"  # 跟踪包下所有类方法
     ```

2. **处理复杂对象：**

   - 调用 `.getClass().getName()`获取对象类名。

   - 使用 `$className`(Frida 特有) 获取类名。

   - 遍历对象字段：

     ```
     let fields = targetObject.getClass().getDeclaredFields();
     for (let i = 0; i < fields.length; i++) {
         fields[i].setAccessible(true);
         console.log(`  ${fields[i].getName()} = ${fields[i].get(targetObject)}`);
     }
     ```

3. **Hook 静态方法：**

   ```
   TargetClass.staticMethod.implementation = function () { ... }
   ```

4. **Hook 系统 API (利用 Android 知识)：**

   ```
   // 示例：Hook Android 日志
   const Log = Java.use("android.util.Log");
   Log.d.implementation = function (tag, msg) {
       let newMsg = "Hooked: " + msg;
       return this.d(tag, newMsg); // 继续输出
   };
   ```

5. **主动调用 Java 方法：**

   ```
   Java.perform(function () {
       const utils = Java.use('com.example.app.Utils');
       let result = utils.encrypt("data"); // 同步调用静态方法
       console.log("Encrypted:", result);
   });
   ```

------

### **七、 调试与排错**

1. **设备连接失败：** 确保 `adb devices`可见，`frida-server`版本与 PC 端 `frida`一致。
2. **Hook 失效：**
   - 检查类名/方法名签名是否完全正确 (重载!)。
   - 确认目标类已加载 (`Java.available`)。
   - `adb logcat | grep -i frida`查看 Frida 内部错误。
3. **脚本语法错误：** `frida_controller.py`的 `on_message`会报告 JS 错误。
4. **性能问题：** 避免在频繁调用的方法中进行高开销操作。

------

### **八、 进阶路径**

1. **多设备管理：** `frida.get_device_manager()`
2. **RPC 调用：** 在 JS 中暴露函数供 Python 主动调用 (实现双向通信)。
3. **持久化 Hook：** 将 `frida-gadget`嵌入 APK (需 repack)。
4. **结合 Xposed 思想：** Hook `ClassLoader`在类加载时拦截。
5. **Frida 反检测：**
   - 隐藏 frida-server 进程名
   - 绕过字符串检测 (`Memory.scan()`抹除特征)

通过结合你的 Java/Kotlin (分析 App 逻辑) + Python (自动化控制) 能力，Frida 将成为你进行 Android 逆向分析、安全测试、动态调试的超级武器！