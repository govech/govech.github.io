## ✅ 一、整体 View 渲染流程（三步）

```
ViewRootImpl.performTraversals()
 ├── measure()
 ├── layout()
 └── draw()
```

我们聚焦第 1 步：

------

## ✅ 二、从 `ViewRootImpl.performTraversals()` 开始

```java
private void performTraversals() {
    ...
    performMeasure();
    ...
}
```

### 🔍 源码片段：`performMeasure()`

```java
private void performMeasure() {
    ...
    view.measure(childWidthMeasureSpec, childHeightMeasureSpec);
    ...
}
```

- `view` 是你的根 View（通常是 `DecorView`）
- `childWidthMeasureSpec` 是系统根据窗口大小和 `LayoutParams` 推算出来的 `MeasureSpec`

------

## ✅ 三、View.measure() 的内部逻辑

```java
public final void measure(int widthMeasureSpec, int heightMeasureSpec) {
    if ((mPrivateFlags & PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ||
        needsLayout()) {
        // 🚩 真正开始测量
        onMeasure(widthMeasureSpec, heightMeasureSpec);
        mPrivateFlags &= ~PFLAG_FORCE_LAYOUT;
    }
}
```

> ✅ 核心点：`onMeasure()` 是测量关键。View/ViewGroup 都会实现它。

------

## ✅ 四、深入 `View.onMeasure()`（默认实现）

```java
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),
                         getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));
}
```

### 🔍 `getDefaultSize(...)` 的源码：

```java
public static int getDefaultSize(int size, int measureSpec) {
    int mode = MeasureSpec.getMode(measureSpec);
    int specSize = MeasureSpec.getSize(measureSpec);

    switch (mode) {
        case MeasureSpec.UNSPECIFIED:
            return size;
        case MeasureSpec.AT_MOST:
        case MeasureSpec.EXACTLY:
        default:
            return specSize;
    }
}
```

🔍 所以默认 `View` 会 **直接接受 MeasureSpec 给的值**，不做自适应处理。

> ❗ 如果你不重写 `onMeasure()`，你的 `wrap_content` 是无效的！

------

## ✅ 五、MeasureSpec 原理深入

```java
public static class MeasureSpec {
    // 低 30 位是 size，高 2 位是 mode
    static final int MODE_SHIFT = 30;
    static final int MODE_MASK  = 0x3 << MODE_SHIFT;

    public static int makeMeasureSpec(int size, int mode) {
        return (size & ~MODE_MASK) | (mode << MODE_SHIFT);
    }

    public static int getMode(int measureSpec) {
        return (measureSpec & MODE_MASK) >> MODE_SHIFT;
    }

    public static int getSize(int measureSpec) {
        return (measureSpec & ~MODE_MASK);
    }
}
```

- `MeasureSpec` 是一个 32 位 int：
  - 高两位表示 Mode
  - 低 30 位表示 Size

------

## ✅ 六、ViewGroup 的 onMeasure：测量子 View

以 `LinearLayout` 为例，看看它是怎么测量每个子 View 的：

### 📌 重点源码：`LinearLayout.onMeasure()`

```java
for (int i = 0; i < count; ++i) {
    View child = getChildAt(i);
    if (child.getVisibility() != GONE) {
        measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0);

        // 记录最大宽高、处理 weight、wrap_content 等逻辑
    }
}
```

### 🔍 核心方法：`measureChildWithMargins(...)`

```java
protected void measureChildWithMargins(
    View child, int parentWidthMeasureSpec, int widthUsed,
    int parentHeightMeasureSpec, int heightUsed
) {
    final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();

    final int childWidthMeasureSpec = getChildMeasureSpec(
        parentWidthMeasureSpec,
        mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed,
        lp.width
    );

    final int childHeightMeasureSpec = getChildMeasureSpec(
        parentHeightMeasureSpec,
        mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed,
        lp.height
    );

    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
}
```

### 🔍 又跳到了：`ViewGroup.getChildMeasureSpec()`

```java
public static int getChildMeasureSpec(int spec, int padding, int childDimension) {
    int specMode = MeasureSpec.getMode(spec);
    int specSize = MeasureSpec.getSize(spec);
    int size = Math.max(0, specSize - padding);

    if (childDimension >= 0) {
        return MeasureSpec.makeMeasureSpec(childDimension, MeasureSpec.EXACTLY);
    } else if (childDimension == LayoutParams.MATCH_PARENT) {
        return MeasureSpec.makeMeasureSpec(size, specMode);
    } else if (childDimension == LayoutParams.WRAP_CONTENT) {
        if (specMode == MeasureSpec.EXACTLY || specMode == MeasureSpec.AT_MOST) {
            return MeasureSpec.makeMeasureSpec(size, MeasureSpec.AT_MOST);
        } else {
            return MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);
        }
    }
}
```

> ✅ 这个方法是关键：**父控件根据自己的 MeasureSpec + padding + 子控件 LayoutParams，构造子控件的 MeasureSpec**

------

## ✅ 七、最终测量完成

所有 `View`、`ViewGroup` 在 `onMeasure()` 内通过子 View 的测量和尺寸确定自己的宽高，并调用：

```java
setMeasuredDimension(measuredWidth, measuredHeight)
```

至此，测量流程结束，进入 layout 阶段。

------

## ✅ 八、流程图总结（超清晰！）

```
ViewRootImpl.performTraversals()
 └── performMeasure()
     └── rootView.measure()
         └── onMeasure()
             ├── View: 计算自己需要的大小
             └── ViewGroup:
                 ├── 遍历子 View
                 ├── getChildMeasureSpec()
                 └── child.measure()
                        └── child.onMeasure()
```

------

## ✅ 九、几点补充

| 要点                       | 说明                                                        |
| -------------------------- | ----------------------------------------------------------- |
| 测量只发生一次？           | 否，有些布局（如 LinearLayout）会测量子 View 两次（weight） |
| wrap_content 会影响吗？    | 会，child.getChildMeasureSpec() 会将 mode 设为 AT_MOST      |
| UNSPECIFIED 模式在哪出现？ | ScrollView、嵌套布局中可能用到                              |



------

## ✅ 十、小结

| 核心步骤                 | 说明                                                  |
| ------------------------ | ----------------------------------------------------- |
| `View.measure()`         | 外部入口，检查是否需要 layout                         |
| `onMeasure()`            | 真正计算宽高的地方                                    |
| `getChildMeasureSpec()`  | 父控件根据自身 MeasureSpec 推算子 View 的 MeasureSpec |
| `setMeasuredDimension()` | 最终设置测量结果                                      |



## ✅ 十一、代码示例

```kotlin
package com.example.myapplicationtest.view

import android.content.Context
import android.util.AttributeSet
import android.view.View
import android.view.ViewGroup

/**
 * 自定义 FlowLayout 布局，用于自动换行排列子视图
 *
 * @param context 上下文，用于初始化视图
 * @param attrs 属性集，包含视图的自定义属性
 */
class FlowLayout @JvmOverloads constructor(
    context: Context,
    attrs: AttributeSet? = null
) : ViewGroup(context, attrs) {

    // 存储所有行的视图集合，每个元素代表一行中的视图列表
    private val allLines = mutableListOf<MutableList<View>>()

    // 存储每行的高度（像素）
    private val lineHeights = mutableListOf<Int>()

    /**
     * 测量流程 - 确定视图及其子视图的大小
     *
     * @param widthMeasureSpec 父容器提供的宽度约束
     * @param heightMeasureSpec 父容器提供的高度约束
     *
     * 测量过程步骤:
     * 1. 解析测量模式和尺寸
     * 2. 测量每个子视图
     * 3. 将子视图分组到行中
     * 4. 计算总高度和最大宽度
     * 5. 设置最终测量尺寸
     */
    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {
        allLines.clear()
        lineHeights.clear()

        val widthMode = MeasureSpec.getMode(widthMeasureSpec)
        val widthSize = MeasureSpec.getSize(widthMeasureSpec)

        val heightMode = MeasureSpec.getMode(heightMeasureSpec)
        val heightSize = MeasureSpec.getSize(heightMeasureSpec)

        val parentWidth = if (widthMode == MeasureSpec.UNSPECIFIED) Int.MAX_VALUE else widthSize


        var lineViews = mutableListOf<View>() // 当前行的视图列表
        var lineWidth = 0  // 当前行已使用的宽度
        var lineHeight = 0 // 当前行最大高度

        var totalHeight = 0  // 布局总高度（所有行高之和）
        var maxLineWidth = 0 // 最大行宽（用于WRAP_CONTENT模式）

        for (i in 0 until childCount) {
            val child = getChildAt(i)
            if (child.visibility == GONE) continue

            // 获取子视图的布局参数（支持Margin）
            val lp = child.layoutParams as MarginLayoutParams


            // paddingLeft：父视图的左内边距。
            // paddingRight：父视图的右内边距。
            // lp.leftMargin：子视图的左外边距，来自其 LayoutParams（如 MarginLayoutParams）。
            // lp.rightMargin：子视图的右外边距。
            // lp.width：子视图的 LayoutParams 中指定的宽度

            // 测量子 View
            val childWidthSpec = getChildMeasureSpec(
                widthMeasureSpec,
                paddingLeft + paddingRight + lp.leftMargin + lp.rightMargin,
                lp.width
            )


            val childHeightSpec = getChildMeasureSpec(
                heightMeasureSpec,
                paddingTop + paddingBottom + lp.topMargin + lp.bottomMargin,
                lp.height
            )
            child.measure(childWidthSpec, childHeightSpec)

            val childWidth = child.measuredWidth + lp.leftMargin + lp.rightMargin
            val childHeight = child.measuredHeight + lp.topMargin + lp.bottomMargin

            // 判断是否需要换行
            if (lineWidth + childWidth > parentWidth) {
                // 保存上一行
                allLines.add(lineViews)
                lineHeights.add(lineHeight)
                totalHeight += lineHeight
                maxLineWidth = maxOf(maxLineWidth, lineWidth)

                // 开启新的一行
                lineViews = mutableListOf()
                lineWidth = 0
                lineHeight = 0
            }

            // 添加当前 View
            lineViews.add(child)
            lineWidth += childWidth
            lineHeight = maxOf(lineHeight, childHeight)
        }

        // 最后一行也需要添加
        allLines.add(lineViews)
        lineHeights.add(lineHeight)
        totalHeight += lineHeight
        maxLineWidth = maxOf(maxLineWidth, lineWidth)

        val finalWidth =
            if (widthMode == MeasureSpec.EXACTLY) widthSize else maxLineWidth + paddingLeft + paddingRight
        val finalHeight =
            if (heightMode == MeasureSpec.EXACTLY) heightSize else totalHeight + paddingTop + paddingBottom

        // 设置最终测量尺寸
        setMeasuredDimension(finalWidth, finalHeight)
    }

    override fun onLayout(changed: Boolean, l: Int, t: Int, r: Int, b: Int) {
        var curTop = paddingTop

        for (i in allLines.indices) {
            val lineViews = allLines[i]
            val lineHeight = lineHeights[i]

            var curLeft = paddingLeft

            for (child in lineViews) {
                if (child.visibility == GONE) continue

                val lp = child.layoutParams as MarginLayoutParams

                val left = curLeft + lp.leftMargin
                val top = curTop + lp.topMargin
                val right = left + child.measuredWidth
                val bottom = top + child.measuredHeight

                child.layout(left, top, right, bottom)

                curLeft += child.measuredWidth + lp.leftMargin + lp.rightMargin
            }

            curTop += lineHeight
        }
    }

    /**
     * 生成支持Margin的布局参数
     *
     * 这使得在XML中可以使用layout_margin属性：
     * <com.example.FlowLayout>
     *     <View android:layout_margin="8dp"/>
     * </com.example.FlowLayout>
     */
    override fun generateLayoutParams(attrs: AttributeSet?): LayoutParams {
        return MarginLayoutParams(context, attrs)
    }

    // 当使用addView(View, LayoutParams)时生成正确的参数类型
    override fun generateDefaultLayoutParams() =
        MarginLayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT)

    // 检查传入的布局参数类型是否有效
    override fun checkLayoutParams(p: LayoutParams?) = p is MarginLayoutParams
}
```

