---
title: Java GC指南
date: 2025-07-20
categories: [Java]
---



Java 开发者无需像 C++ 程序员那样手动管理内存，这得益于 Java 虚拟机（JVM）内置的垃圾回收（Garbage Collection, GC）机制。GC 自动识别并回收不再被使用的对象所占用的内存，从而避免内存泄漏和内存溢出问题。本文档将从 GC 的基础原理出发，逐步深入到分代模型、各类回收器及其高级工作机制。

---

## 一、 GC 的核心原理

Java GC 的工作可以归结为回答两个核心问题：

1.  如何判断对象已“死亡”？
2.  如何回收“死亡”对象占用的内存？

### 1.1 如何判断对象已“死亡”？

主要有两种算法来判断对象是否存活：

* **引用计数法（Reference Counting）**:
    * **原理**：为每个对象维护一个引用计数器。当对象被引用时，计数器加一；引用失效时，计数器减一。当计数器为零时，即表示对象可被回收。
    * **优缺点**：实现简单，回收效率高。但它有一个致命缺陷：**无法解决对象之间的循环引用问题**。因此，现代主流 JVM 均不采用此方法。

* **可达性分析算法（Reachability Analysis）**:
    * **原理**：这是当前主流的实现方式。它将一系列称为 **"GC Roots"** 的对象作为起始点，从这些节点开始向下搜索。搜索所走过的路径称为**引用链（Reference Chain）**。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可达的，即“已死亡”。

#### GC Roots 的进一步阐释

以下是可作为 GC Roots 的核心对象：

1.  **虚拟机栈（VM Stack）中的引用**:
    * **场景**: 方法内的局部变量，如 `Object obj = new Object();`。只要方法还在执行，`obj` 所引用的对象就是存活的。

2.  **方法区（Method Area）中的类静态属性引用的对象**:
    * **场景**: `public static Object myStaticObj = new Object();`。只要类没有被卸载，`myStaticObj` 引用的对象就是存活的。

3.  **方法区（Method Area）中的常量引用的对象**:
    * **场景**: `public static final String MY_CONSTANT = "Hello";`。常量引用的对象，生命周期很长。

4.  **本地方法栈（Native Method Stack）中 JNI 引用的对象**:
    * **场景**: 当 Java 代码调用 C/C++ 等本地代码时，本地代码持有的 Java 对象。

5.  **被同步锁（`synchronized`）持有的对象**:
    * **场景**: `synchronized(myLockObject) { ... }`。在同步块执行期间，锁对象 `myLockObject` 是存活的。

### 1.2 如何回收“死亡”对象的内存？

确定了要回收的对象后，GC 会使用以下几种核心算法来释放内存：

* **标记-清除算法（Mark-Sweep）**:
    * **过程**：分为“标记”和“清除”两个阶段。首先标记出所有需要回收的对象，然后统一清除。
    * **缺点**：效率不高，且会产生大量不连续的**内存碎片**。

* **标记-复制算法（Mark-Copy）**:
    * **过程**：将内存分为大小相等的两块，每次只用其一。当这块内存用完，就将存活对象复制到另一块，再把已用空间一次性清空。
    * **优缺点**：实现简单，无内存碎片。缺点是牺牲了一半的内存空间。

* **标记-整理算法（Mark-Compact）**:
    * **过程**：标记过程与“标记-清除”一样，但后续不是直接清理，而是让所有存活对象都向一端移动，然后直接清理掉边界以外的内存。
    * **优点**：避免了碎片问题，且不像复制算法那样牺牲内存。

---

## 二、 分代垃圾回收：GC 的高效策略

现代 JVM 将上述算法组合使用，并引入了**分代收集（Generational Collection）**策略。它基于一个核心观察：**绝大多数对象生命周期短暂，只有少数对象会长时间存活。**

Java 堆内存通常被划分为：

* **新生代（Young Generation）**: 用于存放新创建的对象。绝大多数对象在这里被创建并很快消亡。
    * **内部结构**：一个 **伊甸园区（Eden Space）** + 两个 **幸存区（Survivor Spaces, S0 和 S1）**。
    * **使用算法**：由于对象存活率低，主要采用**复制算法**，效率极高。

* **老年代（Old Generation）**: 用于存放生命周期较长的对象，或是从新生代“晋升”上来的对象。
    * **使用算法**：对象存活率高，主要采用**标记-清除**或**标记-整理**算法。

### 一个对象的完整生命周期

1.  **诞生于伊甸园 (Eden)**: 绝大多数新对象诞生于此。

2.  **首次幸存 (Minor GC)**: 当 Eden 区满时，触发 **Minor GC**。
    * **STW 开始**: JVM 暂停所有用户线程（这个现象称为 **Stop-the-World, STW**）。
    * **标记与复制**: 将 Eden 和一个幸存区（`From`）中的存活对象，复制到另一个空的幸存区（`To`）。
    * **年龄增长**: 存活对象的内部年龄计数器加 1。
    * **清空与角色互换**: 清空 Eden 和 `From` 区，然后两个幸存区角色互换。
    * **STW 结束**: 恢复用户线程。

3.  **在幸存区之间流转**: 此后的每次 Minor GC，都会重复上述过程，幸存对象的年龄不断增长。

4.  **晋升老年代 (Promotion)**:
    * **年龄达到阈值**: 当对象年龄达到某个值（默认为 15）后，晋升到老年代。
    * **动态年龄判断**: 如果 Survivor 区中某年龄段的对象总大小超过了 Survivor 空间的一半，则大于等于该年龄的对象直接晋升。
    * **大对象直接进入老年代**: 过大的对象会直接在老年代分配。

5.  **老年代的终结 (Major GC / Full GC)**: 当老年代空间不足时，会触发 Major GC 或 Full GC，对整个堆进行回收。这通常比 Minor GC 慢得多，其 STW 时间也更长，是性能优化的重点。

### "Stop-the-World" (STW) 的本质

STW 是 GC 过程中一个无法避免的现象。**所有类型的 GC 都存在 STW 阶段**，区别仅在于 STW 的时长和频率。其目的是为了在进行引用关系分析时，保证内存状态的一致性。GC 技术发展的核心目标之一就是**缩短 STW 的时长**。

---

## 三、 主流垃圾回收器（GC Types）

Java 提供了多种垃圾回收器，它们基于不同的算法和策略，适用于不同的应用场景。

| 回收器         | 特点                                              | 适用场景                                       |
| :------------- | :------------------------------------------------ | :--------------------------------------------- |
| **Serial**     | 单线程 GC，STW 时间长。                           | 客户端模式，单核或小型应用。                   |
| **Parallel**   | 多线程并行 GC，吞吐量优先。**JDK 8 默认**。       | 注重高吞吐量、可容忍较长停顿的后台计算。       |
| **CMS**        | 并发 GC，低延迟优先。                             | 注重服务响应时间，希望系统停顿时间最短的应用。 |
| **G1**         | 将堆划分为区域，可预测停顿时间。**JDK 9+ 默认**。 | 大内存（>4GB）服务器，要求可预测 GC 停顿。     |
| **ZGC**        | 并发 GC，目标是任意堆大小下停顿时间在 10ms 以内。 | 对延迟极其敏感的应用，如金融交易、实时竞价。   |
| **Shenandoah** | 类似 ZGC，也是以极低延迟为目标的并发 GC。         | 对延迟要求苛刻的场景。                         |

### 回收器工作机制深度对比

| 特性/阶段    | Parallel Scavenge / Parallel Old               | CMS (Concurrent Mark Sweep)                                  | G1 (Garbage-First)                                           | ZGC / Shenandoah                                             |
| :----------- | :--------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **核心思想** | **吞吐量优先**。多线程并行处理，尽快完成回收。 | **低延迟优先**。将耗时工作与用户线程并发执行。               | **可预测的停顿时间**。化整为零，优先回收垃圾最多的区域。     | **极低延迟**。几乎所有工作都并发执行，包括对象移动。         |
| **工作流程** | 1.  **完全 STW**: 多线程并行标记、复制/整理。  | 1.  **初始标记 (STW)**: 极快。<br>2.  **并发标记**: 与用户线程并发。<br>3.  **重新标记 (STW)**: 修正。<br>4.  **并发清除**: 与用户线程并发。 | 1.  **初始标记 (STW)**: 极快。<br>2.  **并发标记**: 与用户线程并发。<br>3.  **最终标记 (STW)**: 修正。<br>4.  **筛选回收 (STW)**: 核心阶段。 | 几乎所有阶段都并发执行。STW 仅用于处理 GC Roots 等极少量工作。 |
| **主要缺点** | STW 时间长。                                   | 内存碎片、浮动垃圾、CPU 敏感。                               | 内存占用高、实现复杂。                                       | 技术前沿，需较新 JDK。                                       |

### 现代 GC 的“黑科技”：ZGC 与 Shenandoah

G1 在最后的“筛选回收”阶段（复制对象）依然是 STW 的。ZGC 和 Shenandoah 则攻克了这最后一道难关，实现了**并发的对象移动/整理**。

* **ZGC 的着色指针 (Colored Pointers)**
    * **原理**: 利用 64 位指针的高位来存储元数据（如标记状态）。
    * **读屏障 (Read Barrier)**: 当应用线程读取对象时，读屏障会检查指针上的“颜色”，如果发现对象已被移动，它会负责返回新地址并“自愈”该引用。

* **Shenandoah 的转发指针 (Forwarding Pointers)**
    * **原理**: 当移动一个对象时，在旧对象的位置留下一个指向新地址的“转发指针”。
    * **读/写屏障**: 当用户线程访问对象时，屏障会通过转发指针定位到新地址。

这两种技术都使得 GC 线程可以并发地移动对象，而不用担心用户线程访问到旧地址，从而将 STW 时间压缩到极致，与堆大小完全解耦。

## 四、垃圾收集器（实现GC算法的引擎）

不同的收集器针对不同的目标（低延迟、高吞吐量、大堆、平衡）和代采用了不同的算法实现，常见搭配：

1. **Serial GC (-XX:+UseSerialGC)**
   - 单线程收集器（STW时间长）。
   - 年轻代用**复制算法**，老年代用**标记-整理算法**。
   - 适用于小型应用，客户端模式默认。
2. **Parallel (Throughput) GC (-XX:+UseParallelGC)**
   - 多线程收集器（提升吞吐量）。
   - 年轻代用**并行复制算法**，老年代用**并行标记-整理算法**。
   - 多核环境下追求高吞吐量。在JDK 8之前和之后的某些平台是默认收集器。
3. **Concurrent Mark Sweep GC (-XX:+UseConcMarkSweepGC - 已废弃)**
   - **追求最短停顿时间（Low Pause）**。
   - 年轻代用**并行复制算法**。
   - 老年代用**并发标记-清除算法**（尽量减少Full GC的STW时间）。
   - 缺点是**碎片多**，可能触发并发模式失败导致停顿更长。
4. **Garbage-First GC (-XX:+UseG1GC - JDK 9+默认)**
   - **面向服务端，低延迟与高吞吐平衡**。
   - **Region划分堆**：将堆划分为多个大小相等的Region。
   - **可预测停顿模型**：设定期望停顿时间目标，筛选收益高的Region优先回收（Garbage-First）。
   - **混合回收算法**：新生代Region用**复制算法**，老年代Region主要用**并发标记（Marking）** + **增量清除（Cleanup）**，并在必要时（空间不足）进行**标记-整理**（Full GC）。
   - 适用于大内存（4GB+）应用，是现代主流收集器。
5. **ZGC (-XX:+UseZGC - 低延迟新星)**
   - **亚毫秒级停顿目标**（甚至TB级别堆）。
   - **并发处理**：着色指针 + 读屏障实现几乎所有操作（标记、转移、重定位）都**并发**执行。
   - **Region划分**（N种大小）。
   - **无需老年代划分**：统一处理所有Region。
   - **着色指针**：利用指针上的Bit位信息记录对象状态（标记和重映射）。
   - **读屏障**：在加载对象引用时触发屏障执行所需操作（如对象复制地址更新）。
   - 适用于对延迟要求极端苛刻的场景。
6. **Shenandoah GC (-XX:+UseShenandoahGC)**
   - 同样追求**低停顿**（和ZGC目标相似）。
   - 采用**转发指针 + 读屏障/写屏障 + 并发回收**（包括并发整理）的技术。
   - 与ZGC是竞争关系，各有特点。

## 五、关键特性与挑战

1. Stop-The-World（STW）
   - 在进行GC（特别是初始标记、最终标记阶段）时，**应用线程会被暂停**以保持内存状态一致性。
   - **优化目标**：现代GC（如G1, ZGC, Shenandoah）通过**并发标记、并发清除/整理**等手段最大程度减少STW时间。
2. 安全点（SafePoint）与安全区域（Safe Region）
   - 应用线程执行到特定位置（如方法调用、循环跳转、异常抛出点）时可以安全暂停执行的点叫`安全点`。
   - 无法快速到达安全点的线程（如JNI线程）会进入`安全区域`。
3. 写屏障（Write Barrier）
   - 维护GC所需信息（如卡表）的一种机制，发生在对象引用字段被写入之后。
4. 读屏障（Read Barrier）
   - 发生在对象引用被读取之前（或同时），用于ZGC和Shenandoah等并发GC的处理。
5. 内存碎片
   - 长期运行后，尤其使用`标记-清除`算法，会产生大量不连续的小块内存空间，导致大对象无法分配触发FGC。
   - 解决：整理（Compact）、复制算法；G1/ZGC等的并发整理；分块Region（ZGC/Shenandoah）。

## 六、监控与诊断工具

- `jps`：查看Java进程PID。
- `jstat -gcutil `：监控GC时间、频率、内存使用情况。
- `jmap`：生成堆转储（`-dump`），查看堆概览（`-heap`）。
- `jconsole` / `VisualVM`：图形化监控内存、线程、GC等。
- **垃圾收集日志**：使用`-Xlog:gc*, safepoint`等输出日志，通过GC日志分析工具（如GCViewer, gceasy.io）分析性能瓶颈。

## 七、总结与发展趋势

Java GC的原理是：将堆内存**按对象生命周期分代**（年轻代、老年代、元空间），运用**可达性分析算法**识别垃圾，并针对不同代采用**优化的垃圾收集算法（复制、标记-清除、标记-整理）**，由特定的**垃圾收集器（如Serial, Parallel, CMS, G1, ZGC）** 来执行回收工作。核心挑战在于**平衡吞吐量、延迟和内存开销**，现代GC（ZGC/Shenandoah）通过**高度并发操作、Region划分、读/写屏障技术**实现了极低甚至亚毫秒级的停顿目标。理解GC原理是优化Java应用性能、诊断内存问题的关键基础。

**重点推荐**：对于现代应用，**G1（JDK9+默认）** 通常是良好起点；追求极致低延迟且堆较大（如>64GB）可选择**ZGC**或**Shenandoah**。